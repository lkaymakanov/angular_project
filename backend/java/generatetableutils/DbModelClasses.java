package generatetableutils;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import generatetableutils.Templates.TEMPLATES;



enum MODEL_TYPE {
	MODEL,
	INSERT,
	UPDATE,
	DELETE,
	MODEL_TEST, 
	SELECT,
	SERVICE, 
	CONTROLLER
}

class DbModelClasses extends Var implements DBModelInterface {

	//database table model
	protected Table datatable;  
	
	public String BindVarName = "bindVarData";
		
	//the content of model, modelInsert, modelUpdate, modelDelete files
	protected String model;
	protected String delete = "";
 	protected String insert = "";
	protected String update = "";
	protected boolean useSequence = true;
		
	//root directory to generate  folders & files in
	protected String rootDirectory = "\\java";  //"JavaSource"
	private String rootDirhlp = rootDirectory;
		
	//overridables names & params
	protected String getSqlFunProto = "protected String getSqlString() ";
	protected String preparedStatemenPramName = "prStmt";  //the preparedstatement param name
	protected String setParamsFunProto = "protected void setParameters(PreparedStatement " + preparedStatemenPramName + ") throws SQLException  ";
	protected String FileHeader = "//This file is generated by LAK GenerateUtils...\n" ;
	
	//set this to true if use AbstractModel as base  class
	private boolean useExtendeClassId = true;
	
	//the package
	private String pack = "";  
	
	//instance of update class
	Var updateClassInstance = null;
	
	//instance of select class
	Var selecClassInstance = null;

	//the package of the class
	private String packagee;


	
	public  DbModelClasses(Table t, boolean useSequence){
		initModel(t, useSequence);
	}
	
	public DbModelClasses(Table t){
		initModel(t, false);
	}
	
	
	
	public void initModel(Table t, boolean useSequence){
		if(t == null) return ;
		datatable = t;
		
		//extend abstract Model
		extendedVar = new Var(0, "abstrmodel", 0, "AbstractModel", true);
		extendedVar.vars.add(new Var(Types.NUMERIC, "id", 0, "", false, true));   // the id variable of type long
		
		//use sequence only if table has primary key
		this.useSequence  = useSequence && t.isPrimarykey();  
		
		List<TableColumn> cols = t.getColumns();
		int size = t.getColumns().size();
	    name = "thisInstanceName";
	    varClassName = UtilFun.MakeFirstUpper(UtilFun.RemoveUnderscore(t.getTableName()));
	   
	    
		if(vars == null) vars = new ArrayList<Var>();
		
	    //add variables to model
	    for(int i =0 ; i < size; i++){
	    	TableColumn c = cols.get(i);
	     	  vars.add(new Var(c.getColumnType(), UtilFun.RemoveUnderscore(c.getColumnName()), c.getColumnPrecision(), "",  false, c.isPrimarykey()));
	    }
	}
	

	public String getJavaModel(){
		if(!isValidModel())return null;
		if(model == null){
			model = FileHeader;
			
			//imports
			model += Imports.IMPORT_JAVA_SQL + Imports.IMPORT_BIGDECIMAL + Imports.IMPORT_ABSTRACT_MODEL+
			Imports.IMPORT_JAVAUTIL_DATE;
			
			//commented type script interface
			model+=UtilFun.comment(createJsTypeScriptInterface());
			
			//public class 'NAME' extends 
			String classprolog = KeyWords.PUBLIC + KeyWords.CLASS + varClassName;
				//if we extend other class / model
				if(extendedVar != null && useExtendeClassId) classprolog += Syntax.SPACE + KeyWords.EXTENDS + extendedVar.varClassName;
			classprolog +=Syntax.BEGIN_BLOCK_NEWLN;
			
			String body = "\n\n//member variables...\n";
			
			//get the variables declarations
			for(int i = 0; i < vars.size();i++){
				if(useExtendeClassId && vars.get(i).isPrimaryKey()) continue; 
				body +=  vars.get(i).getVarDecl(1) + "\n";
			}
			
			//get getters & setters  
			body += "\n\n//getters & setters\n";
			for(int i = 0; i < vars.size();i++){
				//if we use extended class AbstractModel don't generate primary key setter & getter actually not usable
				if(useExtendeClassId && vars.get(i).isPrimaryKey()) continue; 
				body +=  vars.get(i).getGetter(1) + "\n";
				body +=  vars.get(i).getSetter(1) + "\n";
			}
			String classepilog = Syntax.END_BLOCK;
			model = model + classprolog + body + classepilog;
		}
		//Application.Log(model);
		return model ;
	}
	
	//select file content
	public String getJavaModelSelect() {
		if(!isValidModel())  return null;
		String st = getSelectFile();
		UtilFun.Log(st);
		return st;
	}
	
	//service file content
	public String getJavaModelService() {
		if(!isValidModel())  return null;
		String st = getServiceFile();
		UtilFun.Log(st);
		return st;
	}
	
	//get controller file content
	private String getJavaController() {
		if(!isValidModel())  return null;
		String st = getControllerFile();
		UtilFun.Log(st);
		return st;
	}



	//insert file content
	public String getJavaModelInsert(){
		if(!isValidModel())  return null;
		  String st = getUpdateFile(MODEL_TYPE.INSERT);
		UtilFun.Log(st);
		return st;
	}
	
	//update file content
	public String getJavaModelUpdate(){
		if(!isValidModel())  return null;
		  String st = getUpdateFile(MODEL_TYPE.UPDATE);
		  UtilFun.Log(st);
		return st;
	}
	
	//delete file content
	public String getJavaModelDelete(){
		if(!isValidModel())  return null;
		  String st = getUpdateFile(MODEL_TYPE.DELETE);
		  UtilFun.Log(st);
		return st;
	}
	
	public String getJavaModelTest(){
		if(!isValidModel()) return null;
		String st = getUpdateFile(MODEL_TYPE.MODEL_TEST);
		UtilFun.Log(st);
		return st;
	}
	
	//the insert String
	private String createInsertString(int indidx){
		String indent = indent(indidx);
		insert = Syntax.QUATATION_MARK + " insert into " + datatable.getTableName() + Syntax.SPACE + 
		Syntax.BRACEOPEN; 
		String colnames = "";
		String valuesbeforekey =  ""; 
		String values = "";
		String valuesafterkey = "";
		String checkPrimary = "";
		boolean bvaluesbeforekey = true;
		
		TableColumn c = null;
		//
		for(int i = 0; i < datatable.getColumns().size();i++){
			c =  datatable.getColumns().get(i);
			
			//column names string
			colnames += (i > 0 ? Syntax.COMMA : "") + c.getColumnName();
			
			//values string
			if(c.isPrimarykey() && useSequence) {
				values +=  (i > 0 ? Syntax.COMMA : Syntax.QUATATION_MARK) + "this_isSequnce";
				checkPrimary = checkId(3, i > 0); //getSequence();
				bvaluesbeforekey = false;
				continue;
			}
			
			if(bvaluesbeforekey) valuesbeforekey +=  (i > 0 ? Syntax.COMMA : "") + Syntax.QUESTION_MARK;
			else valuesafterkey += (i > 0 ? Syntax.COMMA : "") + Syntax.QUESTION_MARK;
		}
		
		//close up colnames, values;
		colnames += Syntax.BRACECLOSE +  " values (";
		values = valuesbeforekey + Syntax.QUATATION_MARK + Syntax.SEMICOLON + checkPrimary +  indent + " sql+= " + Syntax.QUATATION_MARK +   valuesafterkey  + Syntax.BRACECLOSE + Syntax.SPACE_QUATATION_MARK + Syntax.SEMICOLON + Syntax.NEWLINE;
		
		insert = insert + colnames + values;
		return insert;
	}

	
	//the update String
	private String createUpdateString(int indindx){
		String indent = indent(indindx);
		update = indent + Syntax.QUATATION_MARK + " update " + datatable.getTableName() + " set "+ 
		Syntax.SPACE_QUATATION_MARK_PLUS_NEWLINE;
		String colnames = " ";
		String primary = "";
		String where;
		
		TableColumn c = null;
		for(int i = 0; i < datatable.getColumns().size();i++){
			//skip the update of primary key
			c = datatable.getColumns().get(i);
			if(c.isPrimarykey()){ 
				primary = c.getColumnName();
				continue;
			}
			colnames += indent +  Syntax.QUATATION_MARK +  ((i > 0) ? Syntax.COMMA : "")  +    c.getColumnName() + Syntax.EQUALS + Syntax.QUESTION_MARK;
			
			if(i+1 < datatable.getColumns().size()) {
				colnames += Syntax.SPACE_QUATATION_MARK_PLUS_NEWLINE;  //
			}
		}
	
	
		colnames += Syntax.SPACE_QUATATION_MARK_PLUS_NEWLINE;
		where = indent + Syntax.QUATATION_MARK + " where " + primary +" = ? " + Syntax.SPACE_QUATATION_MARK;
		update = update + colnames + where;
		return update + Syntax.SEMICOLON;
	}
	
	
	
	//the delete String 
	private String createDeleteString(){
		if(!isValidModel())  return null;
		delete =  Syntax.QUATATION_MARK + " delete from " + datatable.getTableName() + " where ";
		String primary = "";
		
		for(int i = 0; i < datatable.getColumns().size();i++){
			TableColumn c = datatable.getColumns().get(i);
			if(c.isPrimarykey()) primary = c.getColumnName();
		}
		
		delete = delete + primary + " = ? " + Syntax.SPACE_QUATATION_MARK;
		return delete + Syntax.SEMICOLON;
	}
	
	
	//fill test model
	private String createModelTestString(){
		String modelname = "model";
		String s = KeyWords.PACKAGE + pack + Syntax.SEMICOLON_NEWLN +
		Imports.IMPORT_JAVAUTIL_DATE + Syntax.NEWLINE +
		Imports.IMPORT_BIGDECIMAL + Syntax.NEWLINE +
		KeyWords.PUBLIC + KeyWords.CLASS + varClassName + "Test" + Syntax.BEGIN_BLOCK_NEWLN +
		
		//class prolog
		indent(1) +  KeyWords.PUBLIC + varClassName +  " get" + varClassName + Syntax.BRACEOPEN + Syntax.BRACECLOSE + Syntax.BEGIN_BLOCK_NEWLN+
		
		//model declaration
		indent(2) + varClassName + Syntax.SPACE + modelname + Syntax.EQUALS + KeyWords.NEW + varClassName + Syntax.BRACEOPEN + Syntax.BRACECLOSE + Syntax.SEMICOLON_NEWLN;
		
		//invoke setters
		for(int i = 0 ; i < vars.size(); i++){
			Var  v = vars.get(i);
			//use extended class id
			if(v.isPrimaryKey() && useExtendeClassId && extendedVar!=null && extendedVar.vars.size() > 0 && extendedVar.vars.get(0)!= null){
				//invoke AbstracModel Primary key setter
				s+= indent(2) + extendedVar.vars.get(0).invokeSetter(modelname, UtilFun.getTesParam(v.type, v.precision)) + Syntax.SEMICOLON_NEWLN;
			}
			else {
				s+= indent(2) + v.invokeSetter(modelname, UtilFun.getTesParam(v.type, v.precision)) + Syntax.SEMICOLON_NEWLN;
			}
		}
		
		s+=indent(2) + KeyWords.RETURN + modelname +  Syntax.SEMICOLON_NEWLN;
		s+=indent(1) + Syntax.END_BLOCK_NEWLN +  
		Syntax.END_BLOCK;   //end class
		//Application.Log(s);
		return s;
	}
	
	//create Overridables fun
	//create getSqlString fun
	private String creategetSqlStringFun(int indentIndex, String sql){
		if(sql == null) return null;
		//String  sqlvarname = "sql";
		String fun = "";
		String indent = indent(indentIndex);
		fun += indent + Syntax.OVERRIDE  + Syntax.NEWLINE;
		fun += indent + getSqlFunProto + Syntax.BEGIN_BLOCK_NEWLN;
		//declare String var sql
		fun += indent + Syntax.INDENT + " String sql = " + Syntax.QUATATION_MARK + Syntax.QUATATION_MARK + Syntax.SEMICOLON_NEWLN; 
		fun += indent + Syntax.INDENT + " sql += " + sql;
		fun += indent + Syntax.INDENT + KeyWords.RETURN + " sql " +  Syntax.SEMICOLON_NEWLN;
		fun += indent + Syntax.END_BLOCK_NEWLN;
		return fun;
	}
	
	//create setParams fun
	private String createsetParamsFun(int indentIndex, MODEL_TYPE type){
		if(!isValidModel()) return null;
		String fun = "";
		
		String indent = indent(indentIndex);
		fun += indent + Syntax.OVERRIDE  + Syntax.NEWLINE;
		fun += indent + setParamsFunProto + Syntax.BEGIN_BLOCK_NEWLN;
		
		Var v ,primkey = null;
		String set;
		
		//loop through variables in model
		for(int i = 0 ; i < vars.size(); i++){
			v = vars.get(i);
			
			//keep primary key
			if(v.isPrimaryKey() && !v.isClassVar()) {
					primkey = v;
					
					if(useExtendeClassId && extendedVar!=null && extendedVar.vars.size() > 0 && extendedVar.vars.get(0)!= null){
						primkey = extendedVar.vars.get(0);
						v = primkey;    //use primary key  

					}
					
					//insert && use sequence 
					//if((type == MODEL_TYPE.INSERT) && useSequence) continue; 
					//if(type == MODEL_TYPE.INSERT)  {}
					if(type == MODEL_TYPE.DELETE)  break;
					if(type == MODEL_TYPE.UPDATE)  continue;
			}else{
				if(type == MODEL_TYPE.DELETE)  continue;
			}
			
			
			
			//invoke setter through bind var
			set = "";
			if(v.isPrimaryKey())  set += indent + Syntax.INDENT + checkIdprolog(0);    //check the id if is <> -1
			set += indent + Syntax.INDENT + BindVarName + Syntax.DOT + "set" + UtilFun.MakeFirstUpper(v.getTypeStr()) ;
			set += Syntax.BRACEOPEN ;
			if(isDate(v)){set+= toSQLDate(v.invokeGetter(updateClassInstance.vars.get(0).name)); } 
			else {set+=v.invokeGetter(updateClassInstance.vars.get(0).name);} 
			set += Syntax.BRACECLOSE + Syntax.SEMICOLON;
			fun += set + Syntax.NEWLINE;
		}
		
		//add primary key setter if delete or update
		if(primkey != null && (type == MODEL_TYPE.DELETE || type == MODEL_TYPE.UPDATE))  {
			String prim  = indent + Syntax.INDENT + BindVarName + Syntax.DOT + "set" + UtilFun.MakeFirstUpper(primkey.getTypeStr()) + 
			Syntax.BRACEOPEN + primkey.invokeGetter(updateClassInstance.vars.get(0).name) + Syntax.BRACECLOSE + Syntax.SEMICOLON;
			fun +=prim + Syntax.NEWLINE;
		}
		
		//set parameters
		fun += indent + Syntax.INDENT +  BindVarName + Syntax.DOT + "setParameters" + Syntax.BRACEOPEN + preparedStatemenPramName + Syntax.BRACECLOSE + Syntax.SEMICOLON_NEWLN;
		fun += indent + Syntax.END_BLOCK_NEWLN;
		return fun;
	}
	
	//create Constructor
	private String createUpdateConstructor(int indentIndex, MODEL_TYPE type){
		if(!isValidModel()) return null;
		String constr = "";
		String classnName = updateClassInstance.varClassName;
		String varName = updateClassInstance.vars.get(0).name;
		String ind = indent(indentIndex);
		constr += ind + KeyWords.PUBLIC  + classnName + Syntax.BRACEOPEN + varClassName + " " + varName + " " + Syntax.BRACECLOSE + Syntax.BEGIN_BLOCK_NEWLN;
		constr += ind + Syntax.INDENT +  KeyWords.THIS_DOT  + varName +  Syntax.EQUALS  + varName + " "  + Syntax.SEMICOLON_NEWLN;
		constr += ind + Syntax.END_BLOCK_NEWLN;
		if(type == MODEL_TYPE.DELETE) constr +=createDeleteByIdConstructor(indentIndex);
		UtilFun.Log(constr);
		return constr;
	}
	
	/**Create delete by id constructor*/
	private String createDeleteByIdConstructor(int indentIndex) {
		String classnName = updateClassInstance.varClassName;
		String varName = updateClassInstance.vars.get(0).name;
		String varClassName =  updateClassInstance.vars.get(0).varClassName;
		Var v = new Var(0, "id", indentIndex, "long", true);
		String ind = indent(indentIndex);
		String constr = Syntax.NEWLINE+"";
		constr += ind + KeyWords.PUBLIC  + classnName + Syntax.BRACEOPEN +  " long id " + Syntax.BRACECLOSE + Syntax.BEGIN_BLOCK_NEWLN;
		constr += ind + Syntax.INDENT +  KeyWords.THIS_DOT  + varName +  Syntax.EQUALS  + " new " +  varClassName + "()"  + Syntax.SEMICOLON_NEWLN;
		constr += ind + Syntax.INDENT +  KeyWords.THIS_DOT  +  v.invokeSetter(varName, "id") + Syntax.SEMICOLON_NEWLN ;
		constr += ind + Syntax.END_BLOCK_NEWLN;
		UtilFun.Log(constr);
		return constr;
	}
	
	/**Creates a typescript interface for model*/
	private String createJsTypeScriptInterface() {
		String s = "export interface  I"+varClassName + Syntax.BEGIN_BLOCK_NEWLN;
		if(!vars.isEmpty()) {
			int i =0;
			Var id = new Var(2, "id", 0, "long", false);
			s+= Syntax.INDENT +  id.getJsMapping() + Syntax.COMMA_NEWLINE;
			for( ;i < vars.size()-1; i ++) {
				Var v = vars.get(i);
				if(useExtendeClassId && v.isPrimaryKey()) continue; 
				s+= Syntax.INDENT +  v.getJsMapping() + Syntax.COMMA_NEWLINE;
			}
			Var v = vars.get(vars.size()-1);
			s+=Syntax.INDENT + v.getJsMapping() + Syntax.NEWLINE;
		}
		s+=Syntax.END_BLOCK_NEWLN;
		UtilFun.Log(s);
		return s;
	}
	
	
	
	private String getSelectFile() {
		//file header
		if(!isValidModel()) return null;
		String st = FileHeader;
		TEMPLATES t = Templates.TEMPLATES.SELECT_TEMPLATE;
		Map<String, String> m = t.getEmptyParamMap();
		selecClassInstance = new  Var(0, "model", 0, UtilFun.MakeFirstUpper(varClassName) + "Select", true);
		//variable of model in insert, update delete statements
		Var thisInstance = new Var(0, "model", 0, UtilFun.MakeFirstUpper(varClassName), true);
		m.put("${model}", selecClassInstance.varClassName);
		m.put("${type}", thisInstance.varClassName);
		m.put("${cols}", datatable.getColumnsForSelect());
		m.put("${table}", datatable.getTableName());
		m.put("${id}", datatable.getPrimaryKey() == null ? "" : datatable.getPrimaryKey().getColumnName());
		m.put("${modelpackage}", packagee);
		
		String modelname = "model";
		String res="";
		//retrieve result part
		for(int i = 0 ; i < vars.size(); i++){
			Var  v = vars.get(i);
			String type = UtilFun.MakeFirstUpper(UtilFun.getStringOfType(v.type, v.precision));
			String colname="(\"" +datatable.columns.get(i).getColumnName() + "\")";
			//use extended class id
			if(v.isPrimaryKey() && useExtendeClassId && extendedVar!=null && extendedVar.vars.size() > 0 && extendedVar.vars.get(0)!= null){
				//invoke AbstracModel Primary key setter
				res+= indent(2) + extendedVar.vars.get(0).invokeSetter(modelname, "rs.get" + type + colname) + Syntax.SEMICOLON_NEWLN;
			}
			else {
				res+= indent(2) + v.invokeSetter(modelname, "rs.get" + type+ colname) + Syntax.SEMICOLON_NEWLN;
			}
		}
		
		m.put("${res}", res);
		UtilFun.Log(st);
		return t.fillTemplate(m);
	}
	
	/***
	 * The content of the service file....
	 * @return
	 */
	private String getServiceFile() {
		if(!isValidModel()) return null;
		String st = "";
		TEMPLATES t = Templates.TEMPLATES.SERVICE_TEMPLATE;
		Map<String, String> m = t.getEmptyParamMap();
		Var thisInstance = new Var(0, "model", 0, UtilFun.MakeFirstUpper(varClassName), true);
		selecClassInstance = new  Var(0, "model", 0, UtilFun.MakeFirstUpper(varClassName) + "Service", true);
		m.put("${type}", thisInstance.varClassName);
		m.put("${modelpackage}", packagee);
		st = t.fillTemplate(m);
		UtilFun.Log(st);
		return st;
	}
	
	

	private String getControllerFile() {
		if(!isValidModel()) return null;
		String st = "";
		TEMPLATES t = Templates.TEMPLATES.CONTROLLER_TEMPLATE;
		Map<String, String> m = t.getEmptyParamMap();
		Var thisInstance = new Var(0, "model", 0, UtilFun.MakeFirstUpper(varClassName), true);
		selecClassInstance = new  Var(0, "model", 0, UtilFun.MakeFirstUpper(varClassName) + "Controller", true);
		m.put("${type}", thisInstance.varClassName);
		m.put("${modelpackage}", packagee);
		m.put("${table}", datatable.getTableName());
		m.put("${appconstpackage}", "com.example.demo");
		st = t.fillTemplate(m);
		UtilFun.Log(st);
		return st;
	}


	private String getUpdateFile(MODEL_TYPE type){
		//file header
		if(!isValidModel()) return null;
		String st = FileHeader;
		
		String updateString = null;
		
		//variable of model in insert, update delete statements
		Var thisInstance = new Var(0, "model", 0, UtilFun.MakeFirstUpper(varClassName), true);
		
		switch (type) {
			case MODEL:
				updateString = "";
				break;
			case INSERT:
				updateClassInstance = new  Var(0, "model", 0, UtilFun.MakeFirstUpper(varClassName) + "Insert", true);
				updateClassInstance.extendedVar = new Var(0, "model", 0, "UpdateSqlStatement", true);
				updateClassInstance.vars.add(thisInstance);
				updateString = createInsertString(2);
				break;
			case UPDATE:
				updateClassInstance = new  Var(0, "model", 0, UtilFun.MakeFirstUpper(varClassName) + "Update", true);
				updateClassInstance.extendedVar = new Var(0, "model", 0, "UpdateSqlStatement", true);
				updateClassInstance.vars.add(thisInstance);
				updateString = createUpdateString(2);
				break;
			case DELETE:
				updateClassInstance = new  Var(0, "model", 0, UtilFun.MakeFirstUpper(varClassName) + "Delete", true);
				updateClassInstance.extendedVar = new Var(0, "model", 0, "UpdateSqlStatement", true);
				updateClassInstance.vars.add(thisInstance);
				updateString = createDeleteString();
				break;
			case MODEL_TEST:
				return createModelTestString();
			default:
				break;
		}
		
	
		//manage imports
		st+=Syntax.NEWLINE2;
		String imports = Imports.IMPORT_JAVA_SQL + Imports.IMPORT_UPDATE_STATEMENT +
		Imports.IMPORT_JAVAUTIL_DATE + Syntax.NEWLINE+
		Imports.IMPORT_NET_JAVA_UTIL + Syntax.NEWLINE;
		st += imports;
		
		//begin class declaration
		st+=Syntax.NEWLINE2;
		st += KeyWords.PUBLIC + KeyWords.CLASS + updateClassInstance.varClassName + Syntax.SPACE; 
			//if we extend other class / model
			if(updateClassInstance.extendedVar != null && updateClassInstance.extendedVar.varClassName !=null) 
			st += KeyWords.EXTENDS + updateClassInstance.extendedVar.varClassName;
			st+= Syntax.BEGIN_BLOCK_NEWLN;
			
			//create model variable
			st+=Syntax.NEWLINE2;
			st += createModelVar(1, updateClassInstance.vars.get(0).name);
			
			//create constructor
			st+=Syntax.NEWLINE2;
			st +=createUpdateConstructor(1, type);
			
			//create getsqlString
			st+=Syntax.NEWLINE2;
			st += creategetSqlStringFun(1, updateString);
			
			//createsetparams fun
			st+=Syntax.NEWLINE2;
			st += createsetParamsFun(1, type);
		
		//end class declaration
		st += Syntax.END_BLOCK_NEWLN;
		
		return st;
	}
	

	//create a variable of the Var  type
	private String createModelVar(int indentind, String varname){
		return  indent(indentind) + KeyWords.PRIVATE + varClassName + Syntax.SPACE + varname + Syntax.SEMICOLON_NEWLN;
	}
	
	
	private String getSequence(){
		return " snextval('s_"+ datatable.getTableName() + "')";
	}
	
	public Table getTable() {
		return datatable;
	}
	
	public String getModelName() {
		return name;
	}

	public List<Var> getVars() {
		return vars;
	}
	
	private String indent(int ind){
		return UtilFun.indent(ind);
	}
	
	//check model
	public boolean isValidModel(){
		if(datatable == null) return false;
		if(name == null) return false;
		return true;
	}
	
	
	//check the id
	private String checkId(int indidx, boolean hasComma){
		String indent = indent(indidx);
		     String check = Syntax.NEWLINE2+ indent + checkIdprolog(0) + " sql += " +  Syntax.QUATATION_MARK +   (hasComma ?Syntax.COMMA : "" )  + " ?  " + Syntax.QUATATION_MARK + Syntax.SEMICOLON_NEWLN +
		     indent + KeyWords.ELSE + " sql +=  " + Syntax.QUATATION_MARK  + (hasComma ?Syntax.COMMA : "" ) + getSequence() +   Syntax.QUATATION_MARK + Syntax.SEMICOLON_NEWLN + Syntax.NEWLINE;
		return check;
	}
	
	//id prolog
	private String checkIdprolog(int indidx){
		String indent = indent(indidx);
		return  indent +  KeyWords.IF + Syntax.BRACEOPEN +  extendedVar.vars.get(0).invokeGetter(updateClassInstance.vars.get(0).name) + Syntax.GREATER + " 0"+ Syntax.BRACECLOSE;
	}

	
	//save model to file
	private void saveModel(MODEL_TYPE type) throws IOException{
		String fileContent = "";
		String filename = "";
			switch (type) {
				case CONTROLLER:
					fileContent = getJavaController();
					filename = selecClassInstance.varClassName;
					break;
				case MODEL:
					filename = varClassName; 
					fileContent = getJavaModel();
					break;
				case SELECT:
					fileContent = getJavaModelSelect();
					filename = selecClassInstance.varClassName;
					break;
				case SERVICE:
					fileContent = getJavaModelService();
					filename = selecClassInstance.varClassName;
					break;
				case INSERT:
					fileContent = getJavaModelInsert();
					filename = updateClassInstance.varClassName;
					break;
				case UPDATE:
					fileContent = getJavaModelUpdate();
					filename = updateClassInstance.varClassName;
					break;
				case DELETE:
					fileContent = getJavaModelDelete();
					filename = updateClassInstance.varClassName;
					break;
				case MODEL_TEST:
					fileContent = getJavaModelTest();
					filename = varClassName + "Test";
				default:
					break;
			}
		if(fileContent == null || fileContent.equals("")) return;
		
		
		
		FileWriter wr= createFileInTableDir(filename);
		wr.write(fileContent);
		wr.close();
	}
	
	
	

	

	

	//create the directory for model
	protected void createDirInRootDir(String dirName) throws IOException{
		if(!isValidModel() || dirName == null || dirName.equals("")) return;
		
		int ind = dirName.indexOf("\\");
		if(ind == -1){  //path found 
			createSubDir(rootDirhlp, dirName);  //create last directory
			rootDirhlp += "\\" + dirName;      //extend path
			return;
		}		
		createSubDir(rootDirhlp, dirName.substring(0, ind));
		rootDirhlp += "\\" + dirName.substring(0, ind);     //extend path
		
		createDirInRootDir(dirName.substring(ind+1));       //call recursively
	}
	
	//create subDir in base path
	private void createSubDir(String basedir, String subdir) throws IOException{
		File directory = new File (".");
		String path = directory.getCanonicalPath() + basedir + "\\" + subdir.toLowerCase();
		if(pack!=null && !pack.equals("")) pack += Syntax.DOT;
		pack +=  subdir.toLowerCase();
		new File(path).mkdir();
	}
	

	
	//create the file to write in
	protected FileWriter createFileInTableDir(String filename) throws IOException{
		File directory = new File (".");
		String path = directory.getCanonicalPath();
		FileWriter wr = new FileWriter(path + rootDirhlp +"\\" + filename + KeyWords.JAVA_FILE_EXT);
		return wr;
	}
	
	
	//save files
	public void save(){
		save(null);
	}
	
	private boolean isDate(Var v){
		if(v == null) return false;
		if(!v.isClassVar()
				&& (v.getType() == Types.DATE || v.getType() == Types.TIMESTAMP))
			return true;
		return false;
	}
	
	private String toSQLDate(String in){
		return "DateUtil.toSQLDate(" + in+ ")";	
	}
	
	//save files
	public void save(String subdir){
		try {
			rootDirhlp = rootDirectory;
			pack = "";
			if(subdir == null) createDirInRootDir(varClassName.toLowerCase());   //if no argument create only table dir
			else createDirInRootDir(subdir + "\\" + varClassName.toLowerCase());
			packagee = KeyWords.PACKAGE + Syntax.SPACE + pack + Syntax.SEMICOLON_NEWLN;
			FileHeader +=  packagee;
			
			saveModel(MODEL_TYPE.MODEL);
			saveModel(MODEL_TYPE.SELECT);
			saveModel(MODEL_TYPE.INSERT);
			saveModel(MODEL_TYPE.UPDATE);
			saveModel(MODEL_TYPE.DELETE);
			saveModel(MODEL_TYPE.SERVICE);
			saveModel(MODEL_TYPE.CONTROLLER);
			//saveModel(MODEL_TYPE.MODEL_TEST);
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			UtilFun.Log(e.getMessage());
		}
	}
}
